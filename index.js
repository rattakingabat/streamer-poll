// index.js
// Extens√£o Streamer Poll Event para SillyTavern com nome da personagem autom√°tico e logs no console

// Importa as fun√ß√µes necess√°rias
import { getContext } from "../../extensions.js";
import { eventSource, event_types } from "../../../script.js";
import { registerSlashCommand } from '../../../slash-commands.js';

// Importa a biblioteca js-yaml
importScripts('js-yaml.min.js');

// Obt√©m o contexto do SillyTavern
const context = getContext();

// Vari√°veis globais da extens√£o
let messageCount = 0;
let eventChance = 0.1; // Chance inicial de 10%
const increaseRate = 0.05; // Aumenta 5% a cada mensagem sem evento
const maxChance = 0.5; // Chance m√°xima de 50%
const cooldownMessages = 10; // Cooldown de 10 mensagens ap√≥s um evento
let cooldownCounter = 0; // Contador de cooldown

// Vari√°veis configur√°veis
let numberOfOptions = 4; // N√∫mero de op√ß√µes na enquete (pode ser ajustado)
let pollOptions = [];
let messages = {};

// Fun√ß√£o para carregar o arquivo de configura√ß√£o YAML
function loadConfig() {
    const configUrl = new URL('config.yaml', import.meta.url).href;

    fetch(configUrl)
        .then(response => response.text())
        .then(yamlText => {
            const config = jsyaml.load(yamlText);
            // characterName n√£o √© mais carregado do arquivo de configura√ß√£o
            pollOptions = config.pollOptions || [];
            messages = config.messages || {};

            console.log("Streamer Poll Event: Configura√ß√£o carregada com sucesso.");
            console.log("Op√ß√µes da enquete:", pollOptions);
            console.log("Mensagens personalizadas:", messages);
        })
        .catch(error => {
            console.error("Streamer Poll Event: Erro ao carregar o arquivo de configura√ß√£o:", error);
            // Define valores padr√£o caso ocorra um erro
            pollOptions = [
                "Jogar um novo game",
                "Fazer um desafio",
                "Responder perguntas",
                "Contar uma hist√≥ria engra√ßada",
                "Mostrar bastidores",
                "Iniciar um sorteio",
                "Realizar uma vota√ß√£o de popularidade",
                "Fazer um tutorial ao vivo",
                "Compartilhar dicas exclusivas",
                "Convidar um espectador para participar"
            ];
            messages = {
                pollIntro: `üë©‚Äçüíª *{characterName} sorri para a c√¢mera e diz:* "E a√≠, pessoal! Vamos fazer uma enquete r√°pida! O que voc√™s acham?"\n\n`,
                pollOption: "üîπ {index}. {option}\n",
                pollResult: `üéâ *{characterName} anuncia animadamente:* "E a op√ß√£o vencedora √©... **{winningOption}**! Obrigada por participarem, pessoal!"`
            };

            console.log("Streamer Poll Event: Usando configura√ß√µes padr√£o.");
        });
}

// Chama a fun√ß√£o para carregar a configura√ß√£o ao iniciar a extens√£o
loadConfig();

// Fun√ß√£o para obter o nome da personagem atual
function getCharacterName() {
    // Verifica se h√° uma personagem selecionada
    if (context.characterName && context.characterName !== '') {
        return context.characterName;
    } else {
        // Caso n√£o haja uma personagem selecionada, retorna um nome padr√£o
        return "Personagem";
    }
}

// Fun√ß√£o para embaralhar um array
function shuffleArray(array) {
    const shuffled = array.slice();
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

// Fun√ß√£o para verificar e disparar o evento aleat√≥rio
function checkForRandomEvent() {
    console.log("Streamer Poll Event: Verificando se o evento deve ocorrer...");

    if (cooldownCounter > 0) {
        cooldownCounter--;
        console.log(`Streamer Poll Event: Em cooldown. Mensagens restantes no cooldown: ${cooldownCounter}`);
        return;
    }

    messageCount++;
    console.log(`Streamer Poll Event: Contador de mensagens: ${messageCount}`);

    const randomNumber = Math.random();
    console.log(`Streamer Poll Event: N√∫mero aleat√≥rio gerado: ${randomNumber}`);
    console.log(`Streamer Poll Event: Chance atual do evento: ${eventChance}`);

    if (randomNumber < eventChance) {
        console.log("Streamer Poll Event: Evento disparado!");
        triggerPollEvent();
        // Resetar ap√≥s o evento ocorrer
        messageCount = 0;
        eventChance = 0.1;
        cooldownCounter = cooldownMessages;
        console.log(`Streamer Poll Event: Cooldown iniciado por ${cooldownMessages} mensagens.`);
    } else {
        // Aumentar a chance para a pr√≥xima mensagem
        eventChance = Math.min(eventChance + increaseRate, maxChance);
        console.log(`Streamer Poll Event: Evento n√£o ocorreu. Nova chance do evento: ${eventChance}`);
    }
}

// Fun√ß√£o para substituir placeholders nas mensagens
function formatMessage(template, data) {
    return template.replace(/{(.*?)}/g, (match, key) => data[key.trim()] || "");
}

// Fun√ß√£o para disparar a enquete
function triggerPollEvent() {
    if (pollOptions.length === 0) {
        console.warn("Streamer Poll Event: Nenhuma op√ß√£o de enquete dispon√≠vel.");
        return;
    }

    // Seleciona aleatoriamente as op√ß√µes da enquete
    const shuffledOptions = shuffleArray(pollOptions);
    const options = shuffledOptions.slice(0, numberOfOptions);

    console.log("Streamer Poll Event: Op√ß√µes selecionadas para a enquete:", options);

    // Apresenta a enquete no roleplay
    displayPoll(options);

    // Seleciona aleatoriamente a op√ß√£o vencedora
    const winningIndex = Math.floor(Math.random() * options.length);
    const winningOption = options[winningIndex];

    console.log(`Streamer Poll Event: Op√ß√£o vencedora ser√° anunciada ap√≥s 5 segundos: "${winningOption}"`);

    // Apresenta o resultado ap√≥s um tempo (simulando a dura√ß√£o da enquete)
    setTimeout(() => {
        displayPollResult(winningOption);
    }, 5000); // 5000 milissegundos = 5 segundos
}

// Fun√ß√£o para apresentar a enquete
function displayPoll(options) {
    const characterName = getCharacterName();
    let pollMessage = formatMessage(messages.pollIntro, { characterName });

    options.forEach((option, index) => {
        pollMessage += formatMessage(messages.pollOption, {
            index: index + 1,
            option
        });
    });

    // Adiciona a mensagem ao chat como a personagem
    context.addMessage({
        name: characterName,
        is_user: false,
        is_system: false,
        send_date: Date.now(),
        mes: pollMessage
    });

    console.log("Streamer Poll Event: Enquete apresentada no chat.");
}

// Fun√ß√£o para apresentar o resultado da enquete
function displayPollResult(winningOption) {
    const characterName = getCharacterName();
    const resultMessage = formatMessage(messages.pollResult, {
        characterName,
        winningOption
    });

    // Adiciona a mensagem ao chat como a personagem
    context.addMessage({
        name: characterName,
        is_user: false,
        is_system: false,
        send_date: Date.now(),
        mes: resultMessage
    });

    console.log(`Streamer Poll Event: Resultado da enquete apresentado no chat: "${winningOption}"`);
}

// Evento que √© chamado a cada nova mensagem enviada pelo usu√°rio
function onUserMessage(data) {
    // Verifica se a mensagem foi enviada pelo usu√°rio
    if (data.is_user) {
        console.log("Streamer Poll Event: Nova mensagem do usu√°rio detectada.");
        checkForRandomEvent();
    }
}

// Registra o evento de mensagem enviada
eventSource.on(event_types.MESSAGE_SENT, onUserMessage);

// Comando para redefinir as vari√°veis (pode ser √∫til para testes)
registerSlashCommand("resetpoll", (namedArgs, unnamedArgs) => {
    messageCount = 0;
    eventChance = 0.1;
    cooldownCounter = 0;
    console.log("Streamer Poll Event: Vari√°veis resetadas pelo comando /resetpoll.");
    return "Vari√°veis de enquete resetadas.";
}, [], "Reseta as vari√°veis da extens√£o Streamer Poll Event.");
